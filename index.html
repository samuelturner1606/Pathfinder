<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Pathfinder</title>
		<style>
			html,
			body {
				margin: 0;
				padding: 0;
				background-color: black;
			}
		</style>
	</head>

	<body>
		<canvas></canvas>
		<script>
			(function pathfinderAppLoop() {
				const context = document.querySelector("canvas").getContext("2d");

				// resize canvas
				context.canvas.width = window.innerWidth;
				context.canvas.height = window.innerHeight * 0.8;

				// spawn wall objects
				const wallColour = "rgb(255,255,255)"; // white
				const numOfWalls = 100;
				const wallDensity = 0.05;
				const canvasWidth = context.canvas.width;
				const canvasHeight = context.canvas.height;
				const objectSize = Math.round(
					Math.sqrt((wallDensity * canvasWidth * canvasHeight) / numOfWalls)
				); // pixels
				context.fillStyle = wallColour;

				function randomCoord() {
					const x = Math.round(Math.random() * (canvasWidth - objectSize));
					const y = Math.round(Math.random() * (canvasHeight - objectSize));
					return [x, y];
				}

				for (let i = 0; i < numOfWalls; i++) {
					let spawn = randomCoord();
					context.beginPath();
					context.arc(spawn[0], spawn[1], objectSize, 0, Math.PI * 2, false);
					context.fill();
				}

				// spawn other objects
				const startColour = "rgb(0,0,255)"; // blue
				const endColour = "rgb(255,255,0)"; // yellow
				const portalColour = "rgb(0,255,0)"; // green
				const coordArray = [];
				const portalArray = [];

				function collision(topLeftX, topLeftY) {
					const d = objectSize - 1; // -1 prevents bugs
					const positions = [
						[topLeftX + d / 2, topLeftY + d / 2], // middle
						[topLeftX, topLeftY], // top left
						[topLeftX + d, topLeftY], // top right
						[topLeftX + d, topLeftY + d], // bottom right
						[topLeftX, topLeftY + d], // bottom left
						[topLeftX + d / 2, topLeftY], // top middle
						[topLeftX + d, topLeftY + d / 2], // right middle
						[topLeftX + d / 2, topLeftY + d], // bottom middle
						[topLeftX, topLeftY + d / 2] // left middle
					];

					for (const pos of positions) {
						const pixel = context.getImageData(
							Math.round(pos[0]),
							Math.round(pos[1]),
							1,
							1
						);
						const rgb =
							"rgb(" +
							pixel.data[0] +
							"," +
							pixel.data[1] +
							"," +
							pixel.data[2] +
							")";
						if (rgb != "rgb(0,0,0)") {
							// if rgb isn't canvas background
							return rgb;
						}
					}
				}

				function drawSquare(colour, x, y) {
					context.fillStyle = colour;
					context.fillRect(x, y, objectSize, objectSize);
				}

				function spawnValidObject(objectColour) {
					//  sets new spawn until no object collision
					let spawn = randomCoord();
					while (collision(spawn[0], spawn[1]) != undefined) {
						spawn = randomCoord();
					}
					drawSquare(objectColour, spawn[0], spawn[1]);
					if (objectColour == startColour) {
						coordArray.push(spawn);
					} else if (objectColour == portalColour) {
						portalArray.push(spawn);
					}
				}

				spawnValidObject(startColour);
				for (let i = 0; i < 3; i++) {
					spawnValidObject(endColour);
				}
				for (let i = 0; i < 5; i++) {
					spawnValidObject(portalColour);
				}

				// create coord map that expands from start
				const linearDAlpha = 0.05; // change in pixel alpha
				const diagonalDAlpha = Math.hypot(linearDAlpha, linearDAlpha);
				const coordColour = "rgb(0,255,255)"; // cyan
				const pathArray = [];

				function pixelAlpha(coordX, coordY) {
					const pixel = context.getImageData(coordX, coordY, 1, 1);
					const alpha = pixel.data[3] / 255;
					return alpha;
				}

				function drawNewCoord(dAlpha, alpha, adjCoord) {
					alpha -= dAlpha;
					if (alpha > 0) {
						coordArray.push(adjCoord); // this continues endFinderLoop()
						drawSquare(
							"rgba" + coordColour.slice(3, -1) + "," + alpha + ")",
							adjCoord[0],
							adjCoord[1]
						);
					}
				}

				function updateOldCoord(dAlpha, alpha, adjCoord) {
					alpha -= dAlpha;
					const oldAlpha = pixelAlpha(adjCoord[0], adjCoord[1]);
					if (alpha > oldAlpha) {
						// if brighter than oldAlpha, shortcut found
						context.clearRect(adjCoord[0], adjCoord[1], objectSize, objectSize); // clears old square so alpha can be updated
						drawSquare(
							"rgba" + coordColour.slice(3, -1) + "," + alpha + ")",
							adjCoord[0],
							adjCoord[1]
						);
					}
				}

				function createCoordMap(coordX, coordY) {
					const currentAlpha = pixelAlpha(coordX, coordY);
					const adjCoordArray = [
						[coordX - objectSize, coordY - objectSize], // NW
						[coordX + objectSize, coordY + objectSize], // SE
						[coordX - objectSize, coordY + objectSize], // SW
						[coordX + objectSize, coordY - objectSize], // NE
						[coordX - objectSize, coordY], // W
						[coordX, coordY + objectSize], // S
						[coordX, coordY - objectSize], // N
						[coordX + objectSize, coordY] // E
					];
					for (const adjCoord of adjCoordArray) {
						if (
							// if adjCoord is on canvas
							0 < adjCoord[0] &&
							adjCoord[0] < canvasWidth - objectSize &&
							0 < adjCoord[1] &&
							adjCoord[1] < canvasHeight - objectSize
						) {
							const adjColour = collision(adjCoord[0], adjCoord[1]);
							if (adjColour == undefined) {
								if (adjCoord[0] != coordX && adjCoord[1] != coordY) {
									drawNewCoord(diagonalDAlpha, currentAlpha, adjCoord);
								} else {
									drawNewCoord(linearDAlpha, currentAlpha, adjCoord);
								}
							} else if (adjColour == coordColour) {
								// if returning to existing coord
								if (adjCoord[0] != coordX && adjCoord[1] != coordY) {
									updateOldCoord(diagonalDAlpha, currentAlpha, adjCoord);
								} else {
									updateOldCoord(linearDAlpha, currentAlpha, adjCoord);
								}
							} else if (adjColour == endColour) {
								pathArray.push(adjCoord);
							}
						}
					}
				}

				let coordIndex = 0;
				(function endFinderLoop() {
					const coord = coordArray[coordIndex];
					if (coord != undefined && pathArray.length == 0) {
						// if every coord in array hasn't been checked and end hasn't been found
						window.requestAnimationFrame(endFinderLoop);
						createCoordMap(coord[0], coord[1]);
						coordIndex++;
					} else {
						window.requestAnimationFrame(pathfinderAppLoop);
					}
				})();
			})();
		</script>
	</body>
</html>
